# Dependency injection

We will use [InversifyJS](http://inversify.io/) as DI container. It will help us to decouple our components and inject dependencies them.

    yarn add inversify reflect-metadata

Let's create a new file `di.config.ts` where we put the Inversify initialization logic:

```ts
import { Container } from "inversify";

export default function createContainer() {
  const container = new Container({ skipBaseClassChecks: true });

  // register all components here with container.bind<>().to()...

  return container;
}
```

Add `app.tsx` where the application start logic will take place:

```ts
import { Container } from "inversify";
export function runApp(container: Container) {
  document.writeln("Start the app here");
}
```

Update `index.tsx` with the bootstrap logic:

```ts
import "reflect-metadata";
import { runApp } from "./app";
import createContainer from "./di.config";
import * as serviceWorker from "./serviceWorker";

const container = createContainer();
runApp(container);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();
```

## Decorators

Inversify requires all components that the container can inject to be marked with a decorator `@injectable`. We see it as a code smell to mark all components in their source files with this inversify-specific decorator (and thus introduce a reference to Inversify from their source code). Moreover, all contructor arguments that should be injected need to be marked with a decorator as well.

Let's utilize the feature that decorators can be defined in a different file and put them in a special file `di.decorators.ts`. It will look like this:

```ts
import { decorate, inject, injectable } from "inversify";

decorate(injectable(), MyService); // mark the service as @injectable
decorate(inject(DependencyA) as any, MyService, 0); // mark contructor parameters to be injected
decorate(inject(DependencyB) as any, MyService, 1);
```

## Generator

Files `di.decorators.ts` and `di.registry.ts` can be automatically generated by a script.

    yarn add ts-morph -D

`package.json`

```json
{
  ...
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "generate": "node ./tools/generate.js"
  },
  ...
}
```

In order to use the generated files, update `di.config.ts` as follows:

```ts
import { Container } from "inversify";
import "./di.decorators";
import registerServices from "./di.registry";

export default function createContainer() {
  const container = new Container({ skipBaseClassChecks: true });

  // register all components here with container.bind<>().to()...

  registerServices(container);

  return container;
}
```

### TODO

- Make the generator configurable.
- Generate configuration on a per-module basis

- Factories
